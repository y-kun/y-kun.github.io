---
title: JSR303数据校验
categories: java
tags: java
abbrlink: 293136133
date: 2021-05-10 16:38:07
---
### <font color="#ff0000">导入hibernate-validator包</font>

```java
<dependency>
	<groupId>org.hibernate</groupId>
	<artifactId>hibernate-validator</artifactId>
	<version>5.2.2.Final</version>
</dependency>
```

# 普通校验


## 给Bean添加校验注解：<span class="has-inline-color has-vivid-red-color">javax.validation.constraints</span>，并定义自己的message提示


```java
例：
@NotBlank(message = "品牌名必须提交")
private String name;
```


## 在controller开启校验功能@Valid

```java
例：
public R save(@Valid @RequestBody BrandEntity brand){}
```

## 给校验的bean后紧跟一个BindingResult，就可以获取到校验的结果

```java
例：
public R save(@Valid @RequestBody BrandEntity brand, BindingResult result) {
	if (result.hasErrors()) {
		Map<String, String> map = new HashMap<>();
		// 获取校验的错误结果
		result.getFieldErrors().forEach((item) -> {
			// FieldError 获取到错误提示
			String message = item.getDefaultMessage();
			// 获取错误的属性的名字
			String field = item.getField();
			map.put(field, message);
		});

		return R.error(400, "提交的数据不合法").put("data", map);
	} else {

	}
	brandService.save(brand);
	return R.ok();
}
```

# 分组校验

## 创建分组校验接口

```java
例：
public interface AddGroup {}
```


## 给Bean添加校验注解，给校验注解标注什么情况需要进行校验


```java
例：
@NotBlank(message = "品牌名必须提交",groups = {AddGroup.class})
```


## controller中@Valid修改为@Validated，并标注注解根据哪种分组进行验证

```java
例：
public R save(@Validated({AddGroup.class}) @RequestBody BrandEntity brand){}
```

<font color="#ff0000">注：默认没有指定分组的校验注解@NotBlank，在分组校验情况@Validated({AddGroup.class})下不生效，只会在@Validated生效；</font>

# 自定义校验

## 编写一个自定义的校验注解

```java
例：
public @interface ListValue {
　　// 错误提示信息(需要在resorces下创建ValidationMessages.properties文件)
　　// 并在文件内添加　　包名.ListValue.message=错误提示内容
　　// 包名.ListValue.message　可随意定义，比如aaa(需和properties中的key对应)
	String message() default "{包名.ListValue.message}";

	Class<?>[] groups() default { };

	Class<? extends Payload>[] payload() default { };

	int[] vals() default { };
}
```

## 编写一个自定义的校验器 ConstraintValidator

```java
例：
public class ListValueConstraintValidator implements ConstraintValidator<ListValue,Integer> {

	private Set<Integer> set = new HashSet<>();
	// 初始化方法
	@Override
	public void initialize(ListValue constraintAnnotation) {
		int[] vals = constraintAnnotation.vals();
		for (int val : vals) {
			set.add(val);
		}
	}

	/**
     * @param value   需要校验的值
     * @param context
     * @return
     */
     // 判断是否校验成功
	@Override
	public boolean isValid(Integer value, ConstraintValidatorContext context) {
		return set.contains(value);
	}
}
```

## 关联自定义的校验器和自定义的校验注解

```java
// 在自定义注解上添加：
@Documented
// 校验器可添加多个
@Constraint(validatedBy = { ListValueConstraintValidator.class })
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
```

# 统一的异常处理@ControllerAdvice
```java
@Slf4j
// @ResponseBody
// @ControllerAdvice(basePackages = "需要异常处理的类或包")
@RestControllerAdvice(basePackages = "需要异常处理的类或包")
public class TestExceptionControllerAdvice {

	@ExceptionHandler(value = MethodArgumentNotValidException.class)
	public R handleVaildException(MethodArgumentNotValidException e){
		log.error("数据校验出现问题{}，异常类型：{}", e.getMessage(), e.getClass());
		BindingResult bindingResult = e.getBindingResult();

		Map<String,String> errorMap = new HashMap<>();
		// 校验错误信息：bindingResult.getFieldErrors()
		bindingResult.getFieldErrors().forEach((fieldError)->{
			errorMap.put(fieldError.getField(),fieldError.getDefaultMessage());
		});
		return R.error(500,"参数格式校验失败").put("data",errorMap);
	}

	@ExceptionHandler(value = Throwable.class)
	public R handleException(Throwable throwable){
		log.error("错误：",throwable);
		return R.error(500,"未知异常");
	}
}
```

#  常用的验证条件注解
## 空检查 
@Null 验证对象是否为null 
@NotNull 验证对象是否不为null, 无法查检长度为0的字符串 
@NotBlank 检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格. 
@NotEmpty 检查约束元素是否为NULL或者是EMPTY.

## Booelan检查 
@AssertTrue 验证 Boolean 对象是否为 true 
@AssertFalse 验证 Boolean 对象是否为 false

## 长度检查 
@Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内 
@Length(min=, max=) Validates that the annotated string is between min and max included.

## 日期检查 
@Past 验证 Date 和 Calendar 对象是否在当前时间之前，验证成立的话被注释的元素一定是一个过去的日期 
@Future 验证 Date 和 Calendar 对象是否在当前时间之后 ，验证成立的话被注释的元素一定是一个将来的日期 
@Pattern 验证 String 对象是否符合正则表达式的规则，被注释的元素符合制定的正则表达式，regexp:正则表达式 flags: 指定 Pattern.Flag 的数组，表示正则表达式的相关选项。

## 数值检查 
建议使用在Stirng,Integer类型，不建议使用在int类型上，因为表单值为“”时无法转换为int，但可以转换为Stirng为”“,Integer为null 
@Min 验证 Number 和 String 对象是否大等于指定的值 
@Max 验证 Number 和 String 对象是否小等于指定的值 
@DecimalMax 被标注的值必须不大于约束中指定的最大值. 这个约束的参数是一个通过BigDecimal定义的最大值的字符串表示.小数存在精度 
@DecimalMin 被标注的值必须不小于约束中指定的最小值. 这个约束的参数是一个通过BigDecimal定义的最小值的字符串表示.小数存在精度 
@Digits 验证 Number 和 String 的构成是否合法 
@Digits(integer=,fraction=) 验证字符串是否是符合指定格式的数字，interger指定整数精度，fraction指定小数精度。 
@Range(min=, max=) 被指定的元素必须在合适的范围内 
@Range(min=10000,max=50000,message=”range.bean.wage”) 
@Valid 递归的对关联对象进行校验, 如果关联对象是个集合或者数组,那么对其中的元素进行递归校验,如果是一个map,则对其中的值部分进行校验.(是否进行递归验证) 
@CreditCardNumber信用卡验证 
@Email 验证是否是邮件地址，如果为null,不进行验证，算通过验证。 