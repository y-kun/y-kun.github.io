---
title: C
abbrlink: 1037565863
date: 2021-07-09 11:04:18
categories:
tags:
---

<meta name="referrer" content="no-referrer" />

c程序执行流程图解：

![image-20210624161341384](https://tva1.sinaimg.cn/large/00724TQEgy1grtfd17f6sj30qb0c17b9.jpg)

![image-20210624161900487](https://tvax4.sinaimg.cn/large/00724TQEgy1grtfhvl6okj30p60bqajs.jpg)

值传递和指针传递：

默认传递值的类型：基本数据类型（整数，小数，字符），结构体，公用体

默认传递地址的类型：指针、数组

常量：

- 常量是固定值，在程序执行期间不能改变。这些固定的值，又叫做`字面量`
- 常量可以是任何的基本数据类型
- 常量的值在定义后不能进行修改

整数常量：

整数常量可以是`十进制`、`八进制`或`十六进制`的常量。前缀指定基数：`0X`或`0x`表示`十六进制`，`0`表示`八进制`，`不带前缀`则默认表示`十进制`。整数常量也可以带一个后缀，后缀是`U和L`的组合，`U`表示`无符号整数（unsigned）`，`L`表示`长整数（long）`。后缀可以是大写，也可以是小写，U和L的顺序任意

浮点常量：

浮点常量由整数部分、小数点、小数部分和指数部分组成

字符常量：

字符常量是括在单引号中，它可以是一个普通字符、一个转义序列

字符串常量：

字符串字面值或常量是括再双引号中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符，字符串换行有两种形式：

```c
char str1[20] = "hello \
			word";		// 这种换行会把word前的空格一起输出，如果不想要空格，需要把word放到最前面，例如：
char str2[20] = "hello \
word";		
char str3[20] = "hello"
			"word";		// 不会输出任何空格，除非字符串内本身就有空格
```

定义常量：

- `#define`预处理器
  - 定义形式：#define 常量名 常量值
- `const`关键字



`const`和`#define`的区别

- const定义的常量带类型，define不带类型

- const是在编译、运行时起作用，而define是在编译的预处理阶段起作用

- define只是简单的替换，没有类型检查。简单的字符串替换会导致`边界效应`

  - ```c
    #include <stdio.h>
    
    #define A 2
    #define B A+2
    #define C A/B * 3
    
    int main () {
        // 由于define只是简单的替换，所以B为A+2
    	// C：A/A+2 * 3 -> 2/2+2 * 3 -> 1 + 6 -> 7
        // 如果运算出正常结果，需要定义B为(A+2)
        // C：A/(A+2) * 3 -> 2/(2+2) * 3 -> 0 + 3 -> 0
        // 2/(2+2)由于是整数运算，所以返回值也是整数，即值为0
    	printf("%d",C);
    	return 0;
    }
    ```

    

- const常量可以进行调试，define不行，主要是因为预编译阶段就已经替换掉了，调试的时候就不存在了

- const不能重定义，不能定义两个一样的，而define可以通过undef取消某个符号的定义，再重新定义

- define可以配合#ifdef、#ifndef、#endif来使用，可以让代码更灵活，比如通过#define来启动或者关闭调试信息

  - ```c
    #include <stdio.h>
    
    #define DEBUG
    
    int main () {
    #ifdef DEBUG
    	printf("%s","定义了DEBUG");
    #endif
    #ifndef DEBUG
    	printf("%s","没有定义DEBUG");
    #endif
    	return 0;
    }
    ```

    

二进制和位运算

进制：

- 二进制：0，1，满2进1
  - 原码、反码、补码
    - 二进制的最高位是符号位：0表示整数，1表示负数
    - 正数的原码、补码、反码都是一样的
    - 负数的反码=它的原码符号位不变，其他位取反（0->1，1->0）
    - 负数的补码=它的反码+1
    - 0的反码、补码都是0
    - 在计算机运算的时候，都是以`补码的方式`来运算的
- 十进制：0-9，满10进1
- 八进制：0-7，满8进1，以数字`0开头`表示
- 十六进制：0-9及A-F，满16进1，以`0x或0X开头`表示。A-F不区分大小写

进制转换：

- 第一组（其他进制转十进制）
  - 二进制转十进制（从最低位开始，将每个位上的数提取出来，乘以2的（位数-1）次方，然后求和）
    - 1011 = 1 * 2^0 + 1 * 2^1 + 0 * 2^2 + 1 * 2^3 = 1 + 2 + 0 + 8 = 11
  - 八进制转十进制（从最低位开始，将每个位上的数提取出来，乘以8的（位数-1）次方，然后求和）
    - 0123 = 3 * 8^0 + 2 * 8^1 + 1 * 8^2 = 3 + 16 + 64  = 83
  - 十六进制转十进制（从最低位开始，将每个位上的数提取出来，乘以16的（位数-1）次方，然后求和）
    - 0x34A = 10 * 16^0 + 4 * 16^1 + 3 * 16^2 = 10 + 64 + 768 = 842
- 第二组（十进制转其他进制）
  - 十进制转二进制
    - 将该数不断除以2，直到商为0为止，然后将每步得到的余数倒过来，就是对应的二进制
    - 123 = 123 / 2 = 61...1 `=>` 61 / 2 = 30...1 `=>` 30 / 2 = 15...0 `=>` 15 / 2 = 7...1 `=>` 7 / 2 = 3...1 `=>` 3 / 2 = 1...1 `=>` 1 / 2 = 0...1 `=>` 1101111 `=>` 1111011
  - 十进制转八进制
    - 将该数不断除以8，直到商为0为止，然后将每步得到的余数倒过来，就是对应的八进制
      - 678 = 678 / 8 = 84...6 `=>` 84 / 8 = 10...4 `=>` 10 / 8 = 1...2 `=>` 1 / 8 = 0...1 `=>` 6421 `=>` (0)1246
  - 十进制转十六进制
    - 将该数不断除以16，直到商为0为止，然后将每步得到的余数倒过来，就是对应的十六进制
      - 8912 = 8912 / 16 = 557...0 `=>` 557 / 16 = 34...13(D) `=>` 34 / 16 = 2...2 `=>` 2 / 16 = 0...2 `=>` 0D22 `=>` (0x)22D0
- 第三组（二进制转其他进制）
  - 二进制转八进制
    - 从低位开始，将二进制每三位数一组，转成对应的八位进制数即可
      - 11010101 = 11   010   101 = (0)325
  - 二进制转十六进制
    - 从低位开始，将二进制数每四位一组，转成对应的十六进制数即可
      - 11010101 =  1101   0101 = (0x)D5
- 第四组（其他进制转二进制）
  - 八进制转二进制
    - 将八进制数每一位转成对应的一个三位的二进制数即可
      - 0237 = 010   011   111 = 10011111
  - 十六进制转二进制
    - 将十六进制数每一位转成对应的一个四位的二进制数即可
      - 0x23B =  0010   0011   1011 = 1000111011

位运算：

- &（按位与）：两位全为1，结果为1，否则为0
- |（按位或）：两位有一个为1，结果为1，否则为0
- ^（按位异或）：两个一个为0，一个为1，结果为1，否则为0
- ~（按位取反）：0 -> 1，1 -> 0
- \>\>（二进制右移运算符）：将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃
- \<\<（二进制左移运算符）：将一个运算对象的各二进制位全部左移若干位，左边的二进制位丢弃，右边补0

![image-20210625145216234](https://tva4.sinaimg.cn/large/00724TQEgy1gruilygntkj30us0asqa2.jpg)

![image-20210628104228254](https://tva1.sinaimg.cn/large/00724TQEgy1grxs9126ylj30hq0b7tb3.jpg)

static关键字

- 局部变量使用static修饰
  - 对应静态局部变量在声明时会自动赋予初始值
  - 静态局部变量存储在进程的静态存储区，只会被初始一次，即使函数返回，它的值也会保持不变
- 全局变量使用static修饰
  - 普通全局变量对整个工程可见，其他文件可以使用extern外部声明后直接使用。静态全局变量仅对当前文件可见，其他文件不可访问
- 函数使用static修饰
  - 非静态函数可以在另一个文件中通过extern引用，静态函数只能在声明它的文件中可见

基本数据类型和字符串类型的相互转换

基本数据类型转字符串

```c
#include <stdio.h>

void main() {
	char str1[20]; //字符数组，即字符串
	char str2[20];
	char str3[20];
	int a=20984,b=48090;
	double d=14.309948;
	//说明
	//1. sprintf 是一个系统函数，可以将结果存放到字符串中
	//2. 格式化的结果，会存放到 str1中
	sprintf(str1,"%d %d",a,b);
	sprintf(str2, "%.2f", d);  
	sprintf(str3, "%8.2f", d); //%8.2f 含义是格式化后，一共有8位，小数点后占用2位， 不够用空格占位
	printf("str1=%s str2=%s str3=%s", str1, str2, str3);
	getchar(); 
}
```

字符串转基本数据类型

```c
#include <stdio.h>
#include <stdlib.h>

void main() {
	//字符数组
	char str[10] = "123456";
	char str2[10] = "12.67423";
	char str3[3] = "ab";
	char str4[4] = "111";

	//说明
	//1.  atoi(str) 将 str 转成整数
	int num1 = atoi(str);
	short s1 = atoi(str4);
	//说明
	//1. atof(str2); 将 str2 转成小数 
	double d = atof(str2);
	//说明
	//1. str3[0]  表示获取到 str3这个字符串(数组)的第一个元素  'a'
	char c = str3[0];
	printf("num1=%d d=%f c=%c s1=%d", num1, d, c, s1);//
	getchar();
}
```

预处理命令和宏定义

预处理命令（#if、#elif、#endif）：

- 使用函数库之前，应该使用#include引入对应的头文件。这种`以#开头的命令成为预处理命令`
- 这些在编译之前对源文件进行简单加工的过程，就成为预处理
- 预处理主要是处理以#开头的命令，预处理命令要放在所有函数之外，而且一般都放在源文件的前面
- 预处理是C语言的一个重要功能，由`预处理程序`完成，当对一个源文件进行编译时，`系统将自动调用预处理程序对源程序中的预处理部分做处理`，处理完毕自动进入对源程序的编译
- C语言提供了多种预处理功能，如宏定义、文件包含、条件编译等

宏定义：

- #define叫做宏定义命令，它也是C语言预处理命令的一种。所谓宏定义，就是用一个标识符来表示一个字符串，如果在后面的代码中出现了该标识符，那么就全部替换成指定的字符串
- 在预处理阶段，对程序中所有出现的“宏名”，预处理器都会用宏定义中的字符串去替换，这成为`“宏替换”`或`“宏展开”`
- 宏定义是由源程序中的宏定义命令#define完成的，宏替换是由预处理程序完成的

带参数的宏定义：

- C语言允许宏带有参数。在宏定义中的参数成为“形式参数”，在宏调用中的参数称为“实际参数”
- 对带参数的宏，在展开过程中不仅要进行字符串替换，还要用实参去替换形参
- 带参宏定义的一般形式为`#define 宏名(形参列表) 字符串`，在字符串中可以含有各个形参，调用的一般形式为`宏名(实参列表);`

![image-20210628131800803](https://tvax2.sinaimg.cn/large/00724TQEgy1grxwqu1ijwj30ce0ajjtz.jpg)

```c
char str1[3] = {'a','b'}	// 当数组长度大于实际长度时，会自动在末尾添加'\0'，否则不会添加，导致乱码
char str2[] = {'a','b'}		// 不会自动添加'\0'
char str3[] = "ab";			// 会自动添加'\0'
char* str4 = "ab";			// 会自动添加'\0'
```

指针函数注意事项和细节

- 用指针作为函数返回值时需要注意，函数运行结束后会销毁在它内部定义的所有局部数据，包括局部变量、局部数组和形式参数，函数返回的指针不能指向这些数据
- 函数运行结束后会销毁该函数所有的局部数据，这里所谓的销毁并不是将局部数据所占用的内存全部清零，而是程序放弃对它的使用权限，后面的代码可以使用这块内存
- C语言不支持在调用函数时返回局部变量的地址，如果确实有这样的需求，需要定义局部变量为static变量

函数指针（指向函数的指针）

- 一个函数总是占用一段连续的内存区域，函数名在表达式中有时也会被转换为该函数所在内存区域的首地址
- 把函数的这个首地址（入口地址）赋予一个指针变量，使指针变量指向函数所在的内存区域，然后通过指针变量就可以找到并调用该函数

函数指针定义

returnType (*pointerName)(param list);

- returnType为函数指针指向的函数返回值类型
- pointerName为指针名称
- param list为函数指针指向的函数的参数列表
- 参数列表中可以同时给出参数的类型和名称，也可以只给出参数的类型，省略参数的名称
- 注意`()的优先级高于*`，第一个括号不能省略，如果写作`returnType *pointerName(param list);`就成了函数原型，它表明函数的返回值类型为`returnType *`

```c
#include <stdio.h>

//说明
//1. max 函数
//2. 接收两个int ,返回较大数
int max(int a, int b){
    return a>b ? a : b;
}

int main(){
    int x, y, maxVal;
   
	//说明 函数指针
	//1. 函数指针的名字 pmax
	//2. int 表示 该函数指针指向的函数是返回int 类型
	//3. (int, int) 表示 该函数指针指向的函数形参是接收两个 int 
	//4. 在定义函数指针时，也可以写上形参名  int (*pmax)(int x, int y) = max;
    int (*pmax)(int x, int y) = max;  //
    printf("Input two numbers:");
   
	scanf("%d %d", &x, &y);
	// (*pmax)(x, y) 通过函数指针去调用 函数max
	// 调用方式 2 pmax(x,y)
    maxVal = (*pmax)(x, y);
    printf("Max value: %d pmax=%p pmax本身的地址=%p\n", maxVal, pmax, &pmax);
	getchar();
	getchar();
    return 0;
}
```

![image-20210629130521278](https://tvax4.sinaimg.cn/large/00724TQEgy1grz2292yhlj30hz0apq4e.jpg)

回调函数

- 函数指针变量可以作为某个函数的参数来使用，回调函数就是一个通过函数指针调用的函数
- 回调函数是由别人的函数执行时调用你传入的函数（通过函数指针完成）

```c
#include <stdlib.h> 
#include <stdio.h>
// 回调函数
//1.  int (*f)(void) 
//2. f 就是 函数指针 , 它可以接收的函数是 (返回 int ,没有形参的函数)
//3. f 在这里被 initArray 调用，充当了回调函数角色
void initArray(int *array, int arraySize, int (*f)(void)) {
    int i ;
	//循环10
    for ( i=0; i<arraySize; i++) {
        array[i] = f(); //通过 函数指针调用了 getNextRandomValue 函数
	}
}
 
// 获取随机值
int getNextRandomValue(void) {
    return rand();//rand 系统函数， 会返回一个随机整数
}
 
int main(void) {
    int myarray[10],i; //定义一个数组和 int
  
	//说明
	//1. 调用 initArray 函数
	//2. 传入了一个函数名 getNextRandomValue (地址), 需要使用函数指针接收
	initArray(myarray, 10, getNextRandomValue);
   
	//输出赋值后的数组
	for(i = 0; i < 10; i++) {
        printf("%d ", myarray[i]);
    }
    printf("\n");
	getchar();
    return 0;
}
```

动态内存分配

- 全局变量——内存中的静态存储区
- 非静态的局部变量——内存中的动态存储区——stack 栈
- 临时使用的数据——建立动态内存分配区域，需要时随时开辟，不需要时及时释放——heap 堆
- 根据需要向系统申请所需大小的空间，由于未在声明部分定义其为变量或者数组，不能通过变量名或者数组名来引用这些数据，只能通过指针来引用

相关函数

头文件   #include <stdlib.h>   声明了四个关于内存动态分配的函数

1. 函数原型`void *malloc(usigned int size)`   // memory allocation
   - 作用——在内存的动态存储区(堆)中分配一个长度为size的连续空间
   - 形参size的类型为无符号整型，函数返回值是所分配区域的第一个字节的地址，即此函数是一个指针型函数，返回的指针指向该分配域的开头位置
   - malloc(100);   开辟一个100字节的临时空间，返回值为其第一个字节的地址
2. 函数原型`void *calloc(unsigned n,unsigned size)`
   - 作用——在内存的动态存储区中分配n个长度为size的连续空间，这个空间一般比较大，足以保存一个数组
   - 用calloc函数可以为一堆数组开辟动态存储空间，n为数组元素个数，每个元素长度为size
   - 函数返回指向所分配域的起始位置的指针；分配不成功，返回NULL
   - p = calloc(50,4);   // 开辟一个50 * 4 个字节临时空间，把起始地址分配给指针变量p
3. 函数原型 `void free(void *p)`
   - 作用——释放变量p所指向的动态空间，使这部分空间能重新被其他变量使用
   - p是最近一次调用calloc或malloc函数时的函数返回值
   - free函数无返回值
   - free(p);   // 释放p所指向的已分配的动态空间
4. 函数原型 `void *realloc(void *p,unsigned int size)`
   - 作用——重新分配malloc或clloc函数获得的动态空间大小，将p指向的动态空间大小改变为size，p的值不变，分配失败返回NULL
   - realloc(p,50);   // 将p所指向的已分配的动态空间改为50字节

返回类型说明

C99标准把以上malloc，calloc，realloc函数的基类型定为void类型，这种指针成为`无类型指针(typeless pointer)`，即不指向哪一种具体的类型数据，只表示用来指向一个抽象的类型的数据，即仅提供一个纯地址，而不能指向任何具体的对象

基本原则

- `避免分配大量的小内存块`，分配堆上的内存有一些系统开销，所以分配许多小内存块比分配几个大内存块的系统开销大
- 仅在需要时分配内存。只要`使用完堆上的内存块，就要及时释放`，否则可能会出现`内存泄漏`
- 总是确保释放已分配的内存，在编写分配内存的代码时，就要确定在代码的什么地方释放内存
- 在释放内存前，确保不会无意中覆盖堆上已分配的内存地址，否则程序就会出现`内存泄漏`

指针使用一览

![image-20210708090854581](https://tvax4.sinaimg.cn/large/00724TQEgy1gs99qtwhu1j30ho08xjuj.jpg)

 结构体

```c
#include <stdio.h>

void main() {
	
	/*
	张老太养了两只猫猫:一只名字叫小白,今年3岁,白色。还有一只叫小花,今年100岁,花色。
	请编写一个程序，当用户输入小猫的名字时，就显示该猫的名字，年龄，颜色。
	如果用户输入的小猫名错误，则显示 张老太没有这只猫猫。

	分析：
	1. 猫猫有 三个成员(变量)组成
	2. 使用结构体解决
	*/
	//创建 结构体Cat  【是数据类型】

	struct Cat { // 结构体名 Cat, Cat 就是我们自己构造的一个数据类型
		char * name;  //名字，使用指针，指向一个字符串
		int age; //年龄
		char *color; //颜色
	};
	//使用Cat 结构体，创建变量
	struct Cat cat1; // cat1 就是 struct Cat 的一个变量 
	struct Cat cat2; // cat2 就是 struct Cat 的一个变量 
	//给cat1 的各个成员赋值
	cat1.name = "小白";
	cat1.age = 3;
	cat1.color = "白色";

	//给cat2 的各个成员赋值
	cat2.name = "小花";
	cat2.age = 100;
	cat2.color = "花色";

	//输出两只猫的信息
	printf("\n 第1只猫 name=%s age=%d color=%s", cat1.name, cat1.age, cat1.color);
	printf("\n 第2只猫 name=%s age=%d color=%s", cat2.name, cat2.age, cat2.color);
	
	getchar();
}
```

共用体

所有成员共用一个数据空间，该空间的大小以占用最大的成员为准
